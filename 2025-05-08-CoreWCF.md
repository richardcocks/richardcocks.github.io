---
layout: post
title: My SO question was closed so I'm writing this post on CoreWCF
date: 2025-05-08
description: A question about WCF Streams
tagline: My stackoverflow question was closed so I'm asking into the void about CoreWCF
image: https://richardcocks.github.io/assets/img/1_WCF_Serializing.png
---

# 2025-05-08 My stackoverflow question was closed, so here's a blog post about CoreWCF

I'm preparing a blog post on RPC and IPC between .NET Framework and dotnet 8, but while doing so I ran into an issue with a service getting stuck on CPU cycles.

It's not a good fit for asking Claude, etc., because there's too much confusing to get an LLM to understand whether you're talking about CoreWCF, WCF client on Core (`System.ServiceModel` package ), or WCF on .NET Framework.  This is confusing enough for humans, let alone a machine that will happily autocomplete from an almost identical but subtly different API.

I can't yet tell whether I've found a bug in WCF, because it feels like what I'm trying to do is probably a misunderstanding on how WCF streams are supposed to work.  In some scenarios I'm also quickly hitting maximum message lengths, and that feels like a red flag.

I took my question to StackOverflow. Stack overflow, a familiar home where I cut my teeth on software development. This turned out to be a mistake, because I rushed asking the question. I extracted the classes I thought were pertinent to the question and that could reproduce the issue. I skipped over some boilerplate but poppped a link to the context of the repo in which they were used. I had forgotten this was a big no-no in SO land.

My question immediately attracted 2 close votes.

I went back, rewrote the entire question, now with a complete minimal reproduction of the issue. It now contained all the code needed to reproduce the issue, and nothing  but that code.

Two days later my question got it's third vote for closure, and remains unanswered.

In my frustration I'm writing this blog post, to briefly introduce CoreWCF and hope someone will be able to answer whether I'm doing it wrong.

## Scenario

For the purpose of testing RPC throughput, let's say I want to stream random numbers from one process to another. This way we can test doing it call-by-call or streamed.

 In gRPC the proto file would look something like this:

```proto
syntax = "proto3";

option csharp_namespace = "RandomNumberGrpc";

package randomService;

service RandomProvider {
  rpc NextInt (NextIntRequest) returns (ValueWithSequence);
  rpc Stream (NextIntStreamRequest) returns (stream ValueWithSequence);
}

message NextIntRequest {}
message NextIntStreamRequest{}

message ValueWithSequence {
  int32 sequenceNumber = 1;
  int32 Value = 2;
}
```

In WCF, we define services through `ServiceContract` attributes. For this post I'll just focus on the streaming service. In WCF, it appears we can't strongly type our stream, we have to just make a contract that returns a `Stream`: ( from my understanding of https://learn.microsoft.com/en-us/dotnet/framework/wcf/samples/stream )

Let's look at our service class.

```csharp
namespace RandomNumberCore;

[ServiceContract]
public interface IStreamingService
{
    [OperationContract]
    Stream GetRandomStream();
}
    

public class StreamingService : IStreamingService
{
    public Stream GetRandomStream()
    {
        return new RandomStream(Random.Shared);
    }
}
```

Where `RandomStream` is my own class that exposes `Random.Shared` as a stream:

```csharp
namespace RandomNumberCore;

public class RandomStream : Stream
{
    public RandomStream(Random random)
    {
        this._random = random;
    }
    
    private int _sequence;
    private readonly Random _random;
    public override bool CanRead => true;

    public override bool CanSeek => false;

    public override bool CanWrite => false;

    public override long Length => throw new NotSupportedException();

    // ReSharper disable once ValueParameterNotUsed
    public override long Position { get => _sequence; set => throw new NotSupportedException(); }

    public override void Flush()
    {}
    
    public override int Read(byte[] buffer, int offset, int count)
    {
        var internalBuffer = new Span<byte>(buffer, offset, count);
        _random.NextBytes(internalBuffer);
        _sequence+=count;
        return count;
    }

    public override int Read(Span<byte> buffer)
    {
        _random.NextBytes(buffer);
        _sequence+=buffer.Length;
        return buffer.Length;
    }

    public override long Seek(long offset, SeekOrigin origin)
    {
        throw new NotSupportedException();
    }

    public override void SetLength(long value)
    {
        throw new NotSupportedException();
    }

    public override void Write(byte[] buffer, int offset, int count)
    {
        throw new NotSupportedException();
    }
}
```

A read-only, non-seekable stream that returns random numbers. I've not extensively tested this stream, but it appears to work fine via gRPC.

Let's write a simple client, including the contract:

```csharp
using System.ServiceModel;

namespace RandomNumberConsumerNet8
{
    [ServiceContract]
    public interface IStreamingService
    {
        [OperationContract]
        Stream GetRandomStream();
    }
    public interface IStreamingServiceChannel : IStreamingService, IClientChannel;

    internal class Program
    {
        public static async Task Main(string[] args)
        {
            var cts = new CancellationTokenSource();
            using var channelFactory = new ChannelFactory<IStreamingServiceChannel>(new BasicHttpBinding(BasicHttpSecurityMode.Transport){TransferMode = TransferMode.Streamed, MaxReceivedMessageSize = 1_000_000_000 }, new EndpointAddress("https://localhost:7151/StreamingService.svc"));
            using var service = channelFactory.CreateChannel();
            service.Open();
            using var randomStream = service.GetRandomStream();
            byte[] buffer = new byte[4];
            await randomStream.ReadExactlyAsync(buffer, cts.Token);
            
            Console.WriteLine($"Received bytes {buffer[0]} , {buffer[1]}, {buffer[2]}, {buffer[3]} ");
            service.Close();
            channelFactory.Close();
        }
    }
}
```

Now when I run the server and client, it appears to work:

```
Received bytes 101 , 18, 99, 251
```

OK great, we opened the stream, streamed 4 bytes and then closed service.

But now when I look at my CPU, it's still chugging along. Profiling the server shows it's still trying to write bytes to the stream, well after the client has long ago disconnected.

![Server trace](/assets/img/1_WCF_Serializing.png "It's stuck processing the message")

What is it doing? It's trying to write to the stream, with no hint of back-pressure or sense it shouldn't be doing so. The sending stream doesn't have any sense that it's not being read from.

I'm coming to the conclusion that WCF streaming is not suitable for this, and is only suitable for single bounded streams, not for streams of unknown length or a stream of messages.

But it's not therefore clear what to do in this scenario, of wanting to transfer an unknown quantity of random numbers. Do I go back to requesting numbers via single messages? That has limited throughput. My initial testing showed ~5k messages / sec that way. I could manually increase the buffer so that each message sends a greater quantity of random numbers, but that loses the fidelity, and rather misses the point, this isn't really about random numbers, it's about how quickly we can pass messages between applications.

Do I need to use session mode and coordinate the stream externally to the RPC?

I'm not sure if I've missed the point of WCF streams or something else about WCF tuning entirely, but what I really wish is that this could have been answere don StackOverflow, so others trying something similarly misguided could have learned from my mistakes.